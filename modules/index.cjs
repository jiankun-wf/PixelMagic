var I = Object.defineProperty; var $ = Object.getOwnPropertyDescriptor; var V = Object.getOwnPropertyNames; var q = Object.prototype.hasOwnProperty; var K = (x, t) => { for (var e in t) I(x, e, { get: t[e], enumerable: !0 }) }, J = (x, t, e, n) => { if (t && typeof t == "object" || typeof t == "function") for (let s of V(t)) !q.call(x, s) && s !== e && I(x, s, { get: () => t[s], enumerable: !(n = $(t, s)) || n.enumerable }); return x }; var Q = x => J(I({}, "__esModule", { value: !0 }), x); var W = {}; K(W, { pw: () => _ }); module.exports = Q(W); const N = x => { throw Error(x) }; class y { readAsElement(t) { const e = document.createElement("canvas"); e.width = t.width, e.height = t.height; const n = e.getContext("2d"); n.drawImage(t, 0, 0, e.width, e.height); const s = n.getImageData(0, 0, e.width, e.height); return new B(s) } async readAsDataUrl(t) { t || N("no url\uFF01"); try { const e = await y.resolveWithUrl(t); return Promise.resolve(e) } catch (e) { return Promise.reject(e) } } async readAsData(t) { t.size || N("no content blob"); const e = URL.createObjectURL(t); try { const n = await y.resolveWithUrl(e); return Promise.resolve(n) } catch (n) { return Promise.reject(n) } } static calcResizeLinerFunc(t, e, n, s, r, o) { return (1 - r) * (1 - o) * t + r * (1 - o) * e + (1 - r) * o * n + r * o * s } FILP = { X: 1, Y: 2, XY: 3 }; flip(t, e = this.FILP.XY) { const { size: n, data: s, rows: r, cols: o } = t, { width: a, height: i } = n, h = new B(new ImageData(new Uint8ClampedArray(r * o * 4), a, i)), m = r % 2 === 0 ? Math.floor(r / 2) : Math.floor(r / 2) + 1, M = o % 2 === 0 ? Math.floor(o / 2) : Math.floor(o / 2) + 1; switch (e) { case this.FILP.X: return t.recycle((d, l, c) => { const u = o - c - 1, [R, b, f, p] = d, [A, g, w, E] = t.at(l, u); h.update(l, c, A, g, w, E), h.update(l, u, R, b, f, p) }, 0, r, 0, M), h; case this.FILP.Y: return t.recycle((d, l, c) => { const u = r - l - 1, [R, b, f, p] = d, [A, g, w, E] = t.at(u, c); h.update(l, c, A, g, w, E), h.update(u, c, R, b, f, p) }, 0, m, 0, o), h; case this.FILP.XY: return t.recycle((d, l, c) => { const u = r - l - 1, R = o - c - 1, [b, f, p, A] = d, [g, w, E, G] = t.at(u, R); h.update(l, c, g, w, E, G), h.update(u, R, b, f, p, A) }, 0, r, 0, M), h } } clip(t, e, n, s, r) { const { size: { width: o, height: a } } = t, i = Math.min(e + s, o), h = Math.min(n + r, a), m = Math.max(e, 0), M = Math.max(n, 0), d = i - m, l = h - M, c = new B(new ImageData(new Uint8ClampedArray(d * l * 4), l, d)); return c.recycle((u, R, b) => { const [f, p, A, g] = t.at(R, b); c.update(R, b, f, p, A, g) }), c } RESIZE = { INTER_NEAREST: 1, INTER_LINEAR: 2, INTER_CUBIC: 3 }; resize(t, e, n, s = this.RESIZE.INTER_LINEAR) { const r = new ImageData(new Uint8ClampedArray(n * e * 4), e, n), o = new B(r), { size: { width: a, height: i } } = t, h = a / e, m = i / n; switch (s) { case this.RESIZE.INTER_NEAREST: return o.recycle((M, d, l) => { const c = Math.round(d * h), u = Math.round(l * m), [R, b, f, p] = t.at(c, u); o.update(d, l, R, b, f, p) }), o; case this.RESIZE.INTER_LINEAR: return o.recycle((M, d, l) => { const c = (d + .5) * h - .5, u = (l + .5) * m - .5, R = Math.floor(c), b = Math.floor(u), f = Math.ceil(c), p = Math.ceil(u), A = c - R, g = u - b, [w, E, G, T] = t.at(R, b), [L, C, S, D] = t.at(f, b), [H, O, v, U] = t.at(R, p), [F, Y, k, X] = t.at(f, p), P = y.calcResizeLinerFunc(w, L, H, F, A, g), z = y.calcResizeLinerFunc(E, C, O, Y, A, g), j = y.calcResizeLinerFunc(G, S, v, k, A, g), Z = y.calcResizeLinerFunc(T, D, U, X, A, g); o.update(d, l, P, z, j, Z) }), o; case this.RESIZE.INTER_CUBIC: return o.recycle((M, d, l) => { const c = Math.floor(d * h), u = Math.floor(l * m), R = c - d, b = u - l; let f = 0, p = 0, A = 0, g = 0; for (let w = -1; w < 3; w++)for (let E = -1; E < 3; E++) { let G = c + w, T = u + E; G = Math.max(G, 0), G = Math.min(G, t.rows - 1), T = Math.max(T, 0), T = Math.min(T, t.cols - 1) } }), o } } fade(t, e, n) { const r = (e === "in" ? 1 - n : n) * 255, o = r, a = r, i = r; switch (e) { case "in": t.recycle((h, m, M) => { const [d, l, c] = h; d + l + c > o + a + i && t.update(m, M, 255, 255, 255) }); break; case "out": t.recycle((h, m, M) => { const [d, l, c] = h; d + l + c < o + a + i && t.update(m, M, 255, 255, 255) }); break } } native(t, e = "#000000") { const n = e.slice(1), [s, r, o] = [+`0x${n.slice(0, 2)}`, +`0x${n.slice(2, 4)}`, +`0x${n.slice(4, 6)}`]; t.recycle((a, i, h) => { const [m, M, d] = a; (m !== 255 || M !== 255 || d !== 255) && t.update(i, h, s, r, o) }) } nativeRollback(t) { const e = [0, 0, 0, 0]; t.recycle(n => { const [s, r, o] = n; if (s !== 255 || r !== 255 || o !== 255) return e[0] = s, e[1] = r, e[2] = o, "break" }), t.recycle((n, s, r) => { const [o, a, i] = n; o === e[0] && a === e[1] && i === e[2] ? t.update(s, r, 255, 255, 255) : t.update(s, r, e[0], e[1], e[2]) }) } dropTransparent(t, e = "#FFFFFFff") { const n = e.slice(1), [s, r, o, a] = [+`0x${n.slice(0, 2)}`, +`0x${n.slice(2, 4)}`, +`0x${n.slice(4, 6)}`, n.length >= 8 ? +`0x${n.slice(6, 8)}` : 255]; t.recycle((i, h, m) => { i[3] === 0 && t.update(h, m, s, r, o, a) }) } colorRollback(t) { t.recycle((e, n, s) => { const [r, o, a, i] = e; t.update(n, s, 255 - r, 255 - o, 255 - a, 255 - i) }) } gray(t) { t.recycle((e, n, s) => { const [r, o, a] = e, i = Math.floor(y.rgbToGray(r, o, a)); t.update(n, s, i, i, i) }) } medianBlur(t, e) { e % 2 !== 1 && N("size\u9700\u4E3A\u5947\u6574\u6570\uFF01"); const n = -Math.floor(e / 2), s = Math.abs(n); t.recycle((r, o, a) => { const i = { R: [], G: [], B: [], A: [] }; for (let c = n; c <= s; c++) { let u = o + c; if (!(u < 0 || u >= t.rows)) for (let R = n; R <= s; R++) { let b = a + R; if (b < 0 || b >= t.cols) continue; const [f, p, A, g] = t.at(u, b); i.R.push(f), i.G.push(p), i.B.push(A), i.A.push(g) } } i.R.sort((c, u) => c - u), i.G.sort((c, u) => c - u), i.B.sort((c, u) => c - u), i.A.sort((c, u) => c - u); const h = i.R.length % 2 !== 0; let m, M, d, l; if (h) { const { R: c, G: u, B: R, A: b } = i, f = Math.floor(c.length / 2); m = c[f], M = u[f], d = R[f], l = b[f] } else { const { R: c, G: u, B: R, A: b } = i, f = c.length / 2, p = f - 1; m = Math.round((c[f] + c[p]) / 2), M = Math.round((u[f] + u[p]) / 2), d = Math.round((R[f] + R[p]) / 2), l = Math.round((b[f] + b[p]) / 2) } t.update(o, a, m, M, d) }) } gaussianBlur(t, e, n = 0, s = n) { e % 2 === 0 && N("size\u9700\u4E3A\u5947\u6574\u6570\uFF01"), (!n || n === 0) && (n = .3 * ((e - 1) / 2 - 1) + .8), (!s || s === 0) && (s = n); const r = y.calcGaussianKernel(e, n, s); if (!r.length) return; const o = Math.floor(e / 2); t.recycle((a, i, h) => { let m = 0, M = 0, d = 0, l = 0; for (let c = 0; c < e; c++)for (let u = 0; u < e; u++) { let R = i + c - o, b = h + u - o; R = Math.max(R, 0), R = Math.min(R, t.rows - 1), b = Math.max(b, 0), b = Math.min(b, t.cols - 1); const f = r[c][u], [p, A, g, w] = t.at(R, b); m += p * f, M += A * f, d += g * f, l += w * f } t.update(i, h, Math.round(m), Math.round(M), Math.round(d), Math.round(l)) }) } meanBlur(t, e) { e % 2 === 0 && N("size\u9700\u4E3A\u5947\u6574\u6570\uFF01"); const n = Math.floor(e / 2), s = Math.pow(e, 2); t.recycle((r, o, a) => { let i = 0, h = 0, m = 0, M = 0; for (let d = 0; d < e; d++)for (let l = 0; l < e; l++) { let c = o + d - n, u = a + l - n; c = Math.max(c, 0), c = Math.min(c, t.rows - 1), u = Math.max(u, 0), u = Math.min(u, t.cols - 1); const [R, b, f, p] = t.at(c, u); i += R, h += b, m += f, M += p } t.update(o, a, Math.round(i / s), Math.round(h / s), Math.round(m / s), Math.round(M / s)) }) } static LINER_CONTRAST = 1.5; static BRIGHTNESS_CONTRAST = 50; static SATURATION_CONTRAST = 1.5; LUT(t, e) { if (arguments.length === 1 || !e?.length) { e = new Uint8ClampedArray(256); for (let n = 0; n < 256; n++)e[n] = Math.min(255, Math.floor(n * y.SATURATION_CONTRAST)) } t.recycle((n, s, r) => { const [o, a, i] = n; t.update(s, r, e[o], e[a], e[i]) }) } THRESHOLD_TYPE = { BINARY: 1, BINARY_INV: 2, TRUNC: 3, TOZERO: 4, TOZERO_INV: 5 }; THRESHOLD_MODE = { THRESHOLD: 1, OTSU: 2, MANUAL: 3 }; threshold(t, e, n, s = this.THRESHOLD_TYPE.BINARY, r = this.THRESHOLD_MODE.THRESHOLD) { t.recycle((o, a, i) => { const [h, m, M] = t.at(a, i), d = y.rgbToGray(h, m, M); let l; switch (r) { case this.THRESHOLD_MODE.THRESHOLD: l = y.calcThresholdValue(d, e, n, s); break; case this.THRESHOLD_MODE.OTSU: l = y.calcThresholdValue(d, y.calcOtsuThreshold(t), n, s); break; case this.THRESHOLD_MODE.MANUAL: l = y.calcThresholdValue(d, e, n, s); break }t.update(a, i, l, l, l) }) } dropWhite(t) { t.recycle((e, n, s) => { const [r, o, a, i] = e; r === 255 && o === 255 && a === 255 && i !== 0 && t.update(n, s, void 0, void 0, void 0, 0) }) } groundGlassFilter(t, e = 5, n = !0) { (!e || e <= 0) && N("offset \u9700\u4E3A\u6B63\u6574\u6570\uFF01"); const { rows: s, cols: r } = t, o = s - e, a = r - e; for (let i = 0; i < o; i++)for (let h = 0; h < a; h++) { const m = Math.floor(Math.random() * e), M = i + m, d = h + (n ? m : Math.floor(Math.random() * e)), [l, c, u, R] = t.at(M, d); t.update(i, h, l, c, u, R) } } nostalgiaFilter(t) { t.recycle((e, n, s) => { const [r, o, a] = e, i = Math.min(.393 * r + .769 * o + .189 * a, 255), h = Math.min(.349 * r + .686 * o + .168 * a, 255), m = Math.min(.272 * r + .534 * o + .131 * a, 255); t.update(n, s, i, h, m) }) } fleetingFilter(t, e = 12) { e = Math.round(e), e <= 0 && N("\u56E0\u5B50\u5FC5\u987B\u5927\u4E8E0"), t.recycle((n, s, r) => { const o = n[2], a = Math.sqrt(o) * e; t.update(s, r, void 0, void 0, a) }) } sunLightFilter(t, e, n, s, r = 150) { const { rows: o, cols: a } = t; e = e || Math.floor(o / 2), n = n || Math.floor(a / 2), s = s || Math.min(o, a), t.recycle((i, h, m) => { const M = Math.pow(e - h, 2) + Math.pow(n - m, 2); if (M < Math.pow(s, 2)) { const [d, l, c] = i, u = Math.round(r * (1 - Math.sqrt(M) / s)); t.update(h, m, Math.min(255, Math.max(0, d + u)), Math.min(255, Math.max(0, l + u)), Math.min(255, Math.max(0, c + u))) } }) } static GRAY_SCALE_RED = .2989; static GRAY_SCALE_GREEN = .587; static GRAY_SCALE_BLUE = .114; static rgbToGray(t, e, n) { return t * y.GRAY_SCALE_RED + e * y.GRAY_SCALE_GREEN + n * y.GRAY_SCALE_BLUE } static resolveWithUrl(t) { return new Promise((e, n) => { const s = new Image; s.addEventListener("load", () => { const r = document.createElement("canvas"); r.width = s.width, r.height = s.height; const o = r.getContext("2d"); o.drawImage(s, 0, 0, r.width, r.height); const a = o.getImageData(0, 0, r.width, r.height); e(new B(a)), s.remove(), r.remove() }), s.addEventListener("error", (...r) => { n(r[1]) }), s.setAttribute("src", t) }) } static gaussianFunction(t, e, n, s) { const r = -(t * t / (2 * n * n)), o = -(e * e / (2 * s * s)); return 1 / (2 * Math.PI * n * s) * Math.exp(r + o) } static calcGaussianKernel(t, e, n) { const s = [], r = Math.floor(t / 2); let o = 0; for (let a = -r; a <= r; a++) { const i = r + a; s[i] = []; for (let h = -r; h <= r; h++) { const m = r + h, M = y.gaussianFunction(a, h, e, n); s[i][m] = M, o += M } } for (let a = 0; a < t; a++)for (let i = 0; i < t; i++)s[a][i] /= o; return s } static calcThresholdValue(t, e, n, s) { let r; switch (s) { case 1: r = t < e ? 0 : n; break; case 2: r = t < e ? n : 0; break; case 3: r = t < e ? t : e; break; case 4: r = t < e ? 0 : t; break; case 5: r = t < e ? t : 0; break }return r } static calcOtsuThreshold(t) { const e = new Array(256).fill(0); let n = 0; t.recycle((a, i, h) => { const [m, M, d] = a, l = y.rgbToGray(m, M, d); e[Math.floor(l)]++, n++ }); let s = e.map(a => a / n), r = 0, o = 0; for (let a = 0; a < 256; a++) { let i = s.slice(0, a + 1).reduce((l, c) => l + c, 0), h = 1 - i, m = s.slice(0, a + 1).map((l, c) => c * l).reduce((l, c) => l + c, 0), M = s.slice(a + 1).map((l, c) => c * l).reduce((l, c) => l + c, 0), d = i * h * Math.pow(m / i - M / h, 2); d > o && (o = d, r = a) } return r } } class B { static minPixelSplitWidth = 400; static minPixelSplitHeight = 400; static group(t, e) { const n = this.minPixelSplitWidth, s = this.minPixelSplitHeight, r = window.navigator.hardwareConcurrency, o = t * e; if (r < 1 || n <= 0 || s <= 0 || o <= 0) return null; const a = n * s * r; if (o < a) return null; const i = [], h = Math.min(t, e), m = Math.min(r, Math.floor(h / Math.min(n, s))), M = Math.ceil(Math.sqrt(m)), d = Math.ceil(m / M), l = Math.floor(t / d), c = Math.floor(e / M); for (let u = 0; u < M; u++)for (let R = 0; R < d; R++) { const b = R * l, f = u * c, p = b + Math.max(n, Math.min(t - R * l, l)), A = f + Math.max(s, Math.min(e - u * c, c)); i.push({ x1: b, y1: f, x2: p, y2: A }) } return i } rows; cols; channels; size; data; constructor(t) { this.rows = t.height, this.cols = t.width, this.size = { width: t.width, height: t.height }, this.channels = 4, this.data = t.data } clone() { const { data: t, size: { width: e, height: n } } = this, s = new Uint8ClampedArray(t), r = new ImageData(s, e, n); return new B(r) } delete() { this.data = new Uint8ClampedArray(0) } update(t, e, ...n) { const { data: s } = this, r = this.getAddress(t, e); for (let o = 0; o < 4; o++)n[o] !== void 0 && (s[r[o]] = n[o]) } getAddress(t, e) { const { channels: n, cols: s } = this, r = s * t * n + e * n; return [r, r + 1, r + 2, r + 3] } parallelForRecycle(t) { return navigator.hardwareConcurrency <= 1 || this.rows * this.cols <= B.minPixelSplitWidth * B.minPixelSplitHeight ? this.recycle(t) : new Promise(n => { const { size: { width: s, height: r } } = this, o = B.group(s, r), a = []; let i = 0; for (let h = 0; h < o.length; h++) { const { x1: m, y1: M, x2: d, y2: l } = o[h], c = new Worker("./exec.worker.js"); c.onmessage = u => { i++, i === a.length && n("success") }, a.push(c), c.postMessage({ callback: t, mat: this, startX: m, startY: M, endX: d, endY: l }) } }) } recycle(t, e = 0, n = this.rows, s = 0, r = this.cols) { for (let o = e; o < n; o++)for (let a = s; a < r; a++)t(this.at(o, a), o, a) } at(t, e) { const { data: n } = this, [s, r, o, a] = this.getAddress(t, e); return [n[s], n[r], n[o], n[a]] } imgshow(t, e = !1, n = 0, s = 0) { const r = t instanceof HTMLCanvasElement ? t : document.querySelector(t); r || N("\u65E0\u6CD5\u627E\u5230canvas\u5F53\u524D\u5143\u7D20\uFF01"); const { data: o, size: a } = this, { width: i, height: h } = a, m = new ImageData(o, i, h), M = r.getContext("2d"); e ? (r.width = n, r.height = s, window.createImageBitmap(m, { resizeHeight: s, resizeWidth: n }).then(d => { M.drawImage(d, 0, 0) })) : (r.width = i, r.height = h, M.putImageData(m, 0, 0, 0, 0, r.width, r.height)) } toDataUrl(t, e = 1) { const n = document.createElement("canvas"); return this.imgshow(n), n.toDataURL(t ?? "image/png", e) } toBlob(t, e = 1) { return new Promise((n, s) => { const r = document.createElement("canvas"); this.imgshow(r), r.toBlob(o => { if (!o || !o.size) return s(new Error("\u8F6C\u6362\u5931\u8D25\uFF1A\u4E0D\u5B58\u5728\u7684blob\u6216blob\u5927\u5C0F\u4E3A\u7A7A")); n(o) }, t ?? "image/png", e) }) } } const _ = new y;
